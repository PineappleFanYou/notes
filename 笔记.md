# javaScript高级

#### 面向对象思想

对象定义：万物皆对象，对象是一种语法，由多个无序键值对组合而成 —— 多个键值对的集合

作用：

1.描述复杂的数据

```js
{
  name : '狗蛋',
  age : 12,
  height : 160
}
```

2.封装代码

```js
别人提供的api，就是别人使用对象的语法封装好的代码
document.getElementById(id)
```

**面向对象 —— 主要作用也是封装代码**

用法：

1.抽象出对象的模板

2.创建出一个实例对象

3.指挥实例对象做事情(调用对象的方法和属性)



#### 面向对象的特点

1.封装性 - 把代码封装到函数里面，再把函数封装到对象里面 - 高度封装

2.继承性 - 为了实现代码的复用 - 之前已经把函数封装到对象里面，不同的对象方法是不一样的，如果有同样的行为，但是不同的对象是不能调用别的对象的方法，我们可以使用继承来实现不同的对象调用别人的方法 - 子类可以从父类那里得到一些属性和方法 

3.多态性 - js不支持多态 -  对象表现为多种形态 - 强类型语言才支持



### 拓展

弱类型语言

弱类型 - 类型区分不严格，比如JavaScript，lua...

声明变量的时候，是不知道是什么类型，运行过程中，是允许改变类型

```js
var a;
```

强类型语言

强类型 - 类型区分严格，比如 c++,java...

变量在声明的时候，就知道是什么类型了，运行过程中，是不允许改变变量的类型的

```c++
int a;// 整数
float b;// 浮点数
char c;// 字符类型
int[] arr;// 整数数组
```



### 创建对象的方式

1.字面量

```js
{}
```

2.构造函数

```js
new Object();
```

3.自定义构造函数

```js
function Person(name,age){}
```

自定义构造函数的优点：

1.可以把代码重复使用

2.可以区分不同的对象的所属的类型

缺点：

1.每次创建对象都会创建一个新的函数，该函数的代码每次都是一样的 —— 非常浪费内存



### 原型

定义：原型是一个对象，该对象可以通过构造函数的一个属性得到， `prototype`

作用：可以给实例对象提供方法

用法：

```js
构造函数.prototype.方法名 = function(){}
```

三个对象之间的关系：

1.构造函数.prototype == 原型对象

2.`实例对象.__proto__` == 原型对象

3.原型对象.construtor === 构造函数

原型链图

![04-原型链](D:\课程视频\jQuery&js高级&ajax\0714 js高级第01天\01 - 教学资料\04-原型链.png)

有结论：

1.一家5口里面有 `__proto__`属性的对象会形成一条链条，该链条被称为原型链

2.原型链的上游的方法可以被原型链的下游的对象调用 —— 实现了代码的重复使用

3.原型链的尽头是null



原型链的上游的方法可以被下游使用的现象被称为 —— 继承



#### 原型链

定义：所谓的原型链就是指  `__proto__` 形参链式关系

作用： 实现继承



#### 原型链上面成员的访问规则

成员：属性和方法的简称

原型链上面的成员的访问规则： 就近原则

​    1.如果实例对象身上有自己的方法，优先使用自己的

​    2.如果实例对象身上没有方法，往原型链上查找，找到离我最近的就使用

​    3.如果一直往原型链的上游查找，都找不到，会返回undefined



#### 继承

定义：后代可以使用前代的东西，目的是为了代码的重复使用

用法：

1.借用构造函数实现继承 - 只能实现属性的继承

固定格式

```js
大分类构造函数.call(this,大分类的构造函数的参数一个一个的放进来);

// 大分类
function Person(name,age,gender){
  this.name = name;
  this.age = age;
  this.gender = gender;
}

// 小分类里面借用大分类的构造函数实现继承
function Student(name,age,gender,number){
  // 大分类构造函数.call(this,name,age,gender)
  Person.call(this,name,age,gender);
  this.number = number;
}
```

当我们借用构造函数实现继承的时候，是对实例对添加了好多属性，就会可以实现属性的继承



2.原型继承实现方法的继承

我们需要把小分类的构造函数的原型执行进行修改，修改为指向大分类构造函数的实例对象

```js
小分类构造函数.prototype = new 大分类构造函数();
例如：
Student.prototype = new Person();
// 原型继承会导致原型丢失constructor属性，我们最好手动的补上
Student.prototype.constructor = Student;
```

此时 Student构造函数的实例对象，就可以调用Person原型上面的方法了，就实现了 方法的重复使用

上面的两个方式组合起来实现继承 —— 组合继承



### 函数是对象

所有的函数其实都是 Function 构造函数的实例对象

```js
function fn(a,b){
  return a + b;
}
```

发现使用new Function的方式也可以创建出一个一模一样的功能的函数



#### Function构造函数

```js
var 函数名 = new Function(参数1,参数2,...,函数体)
例如：
var fn = new Function('a','b','return a + b;');// 这个函数和上面的fn的作用是一样的
```



### 三个借用

定义：自己没有，找比人拿过来使用

作用：代码的重复使用



#### 借用和继承的区别

借用：代码别人已经封装好了，我们不是封装代码，而是把以前封装好的代码直接拿过来使用，但是该对象又不是另一个分类的构造函数的实例



继承：是在代码封装的时候使用，而且在特定的条件下使用，必须是满足逻辑的继承，从一个大的分类里面，分出一个小的分类 —— 从父类到子类

大分类到小分类的解释：

比如说：狗会走路，人也会走路 —— 就不能使用继承

如果执意要用继承来实现代码的重复使用，把狗和人的共同的分类先抽象出来，然后给该分类添加走路的方法

比如： 狗和人都属于动物，先抽象一个动物类，然后在使用继承的方式，让狗和人，继承动物类，就可以实现代码的重复使用



#### 借用的三个方法

函数的原型上面有三个方法

call/apply/bind 这三个方法是专门用于借用







